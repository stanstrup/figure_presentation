# Heatmap Scaling {background-color="#e67e22"}

## The Outlier Problem

**Scenario**: Gene expression data

- 99% of values: -3 to +3
- 1 outlier gene: +6

::: {.fragment}
**What happens with default scaling?**

Color scale: -6 to +6

Result: All the colors look pale and differences are obscured ðŸ˜±
:::

## Visual Example: The Outlier Effect

```{r}
#| label: setup-heatmaps
#| echo: false
#| eval: true

library(ggplot2)
library(pheatmap)
library(RColorBrewer)
library(patchwork)
library(massageR)
```

```{r}
#| label: heatmap-outlier-example
#| echo: false
#| eval: true
#| fig-width: 10
#| fig-height: 5

# Simulate data with outlier
set.seed(123)
expr_matrix <- matrix(rnorm(100, mean = 0, sd = 1), nrow = 10)
rownames(expr_matrix) <- paste0("Gene", 1:10)
colnames(expr_matrix) <- paste0("Sample", 1:10)
expr_matrix[5, 5] <- 6  # One extreme outlier

# Use divergent ColorBrewer scale with white at 0
# RdBu = Red-Blue divergent scale (reversed so blue is positive)
pheatmap(expr_matrix,
         main = "With outlier: All data compressed!",
         color = colorRampPalette(rev(brewer.pal(11, "RdBu")))(100),
         breaks = seq(-6, 6, length.out = 101))
```

::: {.fragment}
**Without Outlier Handling**

- Scale: -6 to +6
- ~99.7% of data: -3 to +3 (Â±3 SD)
- Uses only halfthe color range
- Real patterns invisible
:::



## Solution 1: Standard Deviation Cutoffs

```{r}
#| label: sd-cutoff
#| echo: true
#| eval: true

# Step 1: Scale to unit variance (mean=0, sd=1)
expr_scaled <- t(scale(t(expr_matrix)))

# Step 2: Cap at Â±3 (now meaningful after scaling!)
expr_capped <- pmin(pmax(expr_scaled, -3), 3)

p <- pheatmap(expr_capped,
              main = "Scaled + capped at Â±3",
              color = colorRampPalette(rev(brewer.pal(11, "RdBu")))(100),
              breaks = seq(-3, 3, length.out = 101),
              scale = "none")  # Already scaled!
```

::: {.columns}
::: {.column width="60%"}
```{r}
#| echo: false
#| eval: true
#| fig-width: 8
#| fig-height: 6
p
```
:::

::: {.column width="40%"}
**Most common approach**

- **Scale FIRST** to unit variance
- Then cap at Â±2 or Â±3
- Â±3 captures ~99.7% of data
- Uses full color range
- Set `scale = "none"` (already scaled!)
:::
:::

## Solution 2: Quantile-Based

```{r}
#| label: quantile-cutoff
#| echo: true
#| eval: true

# Cap at 5th and 95th percentiles
lower <- quantile(expr_matrix, 0.05, na.rm = TRUE)
upper <- quantile(expr_matrix, 0.95, na.rm = TRUE)

expr_quantile <- pmin(pmax(expr_matrix, lower), upper)

p <- pheatmap(expr_quantile,
              main = "Values capped at 5-95 percentiles",
              color = colorRampPalette(rev(brewer.pal(11, "RdBu")))(100))
```

::: {.columns}
::: {.column width="60%"}
```{r}
#| echo: false
#| eval: true
#| fig-width: 8
#| fig-height: 6
p
```
:::

::: {.column width="40%"}
**More robust approach**

- Uses percentiles instead of SD
- Not affected by extreme outliers
- Good for non-normal data
- Common: 5-95% or 2-98%
:::
:::

## Solution 3: Manual Breaks

```{r}
#| label: manual-breaks
#| echo: true
#| eval: true

# Step 1: Scale to unit variance first
expr_scaled <- t(scale(t(expr_matrix)))

# Step 2: Define your own color breaks
breaks <- seq(-3, 3, length.out = 101)

p <- pheatmap(expr_scaled,
              breaks = breaks,
              main = "Scaled + custom breaks: -3 to +3",
              color = colorRampPalette(rev(brewer.pal(11, "RdBu")))(100),
              scale = "none")  # Already scaled!

# Values outside range automatically assigned to extremes
```

::: {.columns}
::: {.column width="60%"}
```{r}
#| echo: false
#| eval: true
#| fig-width: 8
#| fig-height: 6
p
```
:::

::: {.column width="40%"}
**Maximum control**

- **Scale FIRST** to unit variance
- Then define exact breaks
- Values outside range â†’ extremes
- Good when you know your data
- Can combine with capping
:::
:::

## Solution 4: Log Transformation

**For positive values only** (e.g., counts, intensities)

```{r}
#| label: log-transform
#| echo: true
#| eval: true

# Create positive data (e.g., count data)
set.seed(123)
count_matrix <- matrix(rpois(100, lambda = 50), nrow = 10)
count_matrix[5, 5] <- 5000  # Extreme count
rownames(count_matrix) <- paste0("Gene", 1:10)
colnames(count_matrix) <- paste0("Sample", 1:10)

# Log transform BEFORE plotting
count_log <- log10(count_matrix + 1)  # +1 to handle zeros

p <- pheatmap(count_log,
              main = "Log10 transformed counts",
              color = colorRampPalette(rev(brewer.pal(11, "RdBu")))(100))
```

::: {.columns}
::: {.column width="60%"}
```{r}
#| echo: false
#| eval: true
#| fig-width: 8
#| fig-height: 6
p
```
:::

::: {.column width="40%"}
**For count/intensity data**

- Compresses wide ranges
- Add +1 to handle zeros
- Common for RNA-seq, proteomics
- Use log2, log10, or ln
:::
:::



## The Dendrogram Scaling Trap

::: {.callout-warning}
## Hidden Technical Issue

**Critical R bug**: Functions like `heatmap()`, `heatmap.2()`, and `heatplot()` have a dangerous inconsistency:

- The `scale` parameter affects **color visualization**
- But **NOT** dendrogram calculation!

**Result**: Dendrograms cluster on unscaled data while colors show scaled data!
:::





## Why Scaling Matters for Clustering

**The Problem: High-variance features dominate distance**

Without scaling, features with large values dominate sample similarity!

```{r}
#| label: scaling-demo
#| echo: true
#| eval: true
#| fig-width: 12
#| fig-height: 5

set.seed(42)

# Create sample clustering example (genes Ã— samples)
# Gene 1: small variation (0-1 range)
# Gene 2: HUGE variation (0-1000 range) - dominates if not scaled!
gene_data <- data.frame(
  Sample1 = c(0.5, 100),
  Sample2 = c(0.6, 150),
  Sample3 = c(0.55, 900),
  Sample4 = c(0.58, 950),
  row.names = c("Gene1", "Gene2")
)

# Calculate sample distances WITHOUT scaling
dist_unscaled <- dist(t(gene_data))

# Calculate sample distances WITH scaling
gene_scaled <- t(scale(t(gene_data)))
dist_scaled <- dist(t(gene_scaled))

# Visualize
par(mfrow = c(1, 2))

# Unscaled: Gene2 dominates!
plot(hclust(dist_unscaled), main = "Unscaled: Gene2 dominates clustering",
     xlab = paste("Sample1-2 close, Sample3-4 close\n",
                  "(only Gene2 matters!)"))

# Scaled: Both genes contribute
plot(hclust(dist_scaled), main = "Scaled: Both genes contribute equally",
     xlab = "Different clustering pattern")
```

::: {.fragment}
**Key point**: Without scaling, high-variance features (Gene2) completely dominate the distance calculation between samples!

Scaling by row ensures all features contribute equally to sample clustering.
:::

## Proper Heatmap Workflow

::: {.callout-important}
## The Right Approach

1. **Scale your data FIRST** (before creating heatmap)
2. **Calculate dendrograms on scaled data**
3. **Pass pre-calculated dendrograms to heatmap function**
4. **Set `scale = "none"`** in heatmap call

```r
# Proper workflow
data_scaled <- t(scale(t(expr_matrix)))  # Scale by row
data_capped <- pmin(pmax(data_scaled, -3), 3)  # Cap extremes

# Calculate dendrograms on scaled data
row_dend <- hclust(dist(data_capped))
col_dend <- hclust(dist(t(data_capped)))

# Plot with pre-computed dendrograms
pheatmap(data_capped,
         cluster_rows = row_dend,
         cluster_cols = col_dend,
         scale = "none")  # Already scaled!
```
:::

## Using massageR::heat.clust

::: {.callout-tip}
## Better Approach: heat.clust

The `massageR` package provides `heat.clust()` which handles scaling and dendrogram calculation correctly in one step!

**Key advantages:**

- Scales data and calculates dendrograms together
- Controls exactly where limits are applied (data and/or dendrograms)
- Returns pre-computed dendrograms
- Works seamlessly with pheatmap
:::

## heat.clust with pheatmap

```{r}
#| label: heat-clust-pheatmap
#| echo: true
#| eval: true
#| fig-width: 10
#| fig-height: 6

library(massageR)

# Use heat.clust to scale and cluster
z <- heat.clust(expr_matrix,
                scaledim = "row",           # Scale by row
                zlim = c(-3, 3),            # Cap at Â±3
                zlim_select = c("dend", "outdata"),  # Apply to both
                reorder = c("column", "row"),        # Reorder dendrograms
                distfun = function(x) dist(x),
                hclustfun = function(x) hclust(x, method = "complete"),
                scalefun = scale)

# Extract dendrograms and convert to hclust objects
row_dend <- as.hclust(z$Rowv)
col_dend <- as.hclust(z$Colv)

# Use with pheatmap
pheatmap(z$data,
         cluster_rows = row_dend,
         cluster_cols = col_dend,
         scale = "none",
         color = colorRampPalette(rev(brewer.pal(11, "RdBu")))(100),
         breaks = seq(-3, 3, length.out = 101),
         main = "heat.clust + pheatmap: Properly scaled!")
```

## Complete Example: Proper Scaling

```{r}
#| label: proper-scaling-example
#| echo: true
#| eval: true
#| fig-width: 10
#| fig-height: 6

# Step 1: Scale by row (gene)
data_scaled <- t(scale(t(expr_matrix)))

# Step 2: Cap extremes at Â±2.5
data_capped <- pmin(pmax(data_scaled, -2.5), 2.5)

# Step 3: Calculate dendrograms on scaled data
row_dend <- hclust(dist(data_capped))
col_dend <- hclust(dist(t(data_capped)))

# Step 4: Plot with consistent scaling
pheatmap(data_capped,
         cluster_rows = row_dend,
         cluster_cols = col_dend,
         scale = "none",
         color = colorRampPalette(rev(brewer.pal(11, "RdBu")))(100),
         breaks = seq(-2.5, 2.5, length.out = 101),
         main = "Properly scaled: dendrograms match colors!")
```

## Diverging Scales for Centered Data

```{r}
#| label: diverging-scale
#| echo: true
#| eval: true
#| fig-width: 10
#| fig-height: 5

# When zero is meaningful (fold-change, z-scores, etc.)
pheatmap(data_capped,
         color = colorRampPalette(rev(brewer.pal(11, "RdBu")))(100),
         breaks = seq(-2.5, 2.5, length.out = 101),
         main = "Diverging scale: zero = white")

# Zero = white, negative = blue, positive = red
```

## When NOT to Cap

::: {.callout-warning}
## Don't cap blindly!

- If outliers are **biologically meaningful** (rare events)
- Small datasets where each value matters
- When you want to highlight extreme values

**Alternative**: Use asterisks or separate panel for outliers
:::

## Comparison: Before and After

```{r}
#| label: heatmap-comparison
#| echo: true
#| eval: true
#| fig-width: 14
#| fig-height: 6

# Side-by-side comparison
library(gridExtra)

# Before: with outlier
p1 <- pheatmap(expr_matrix,
               main = "Uncapped: Pattern lost",
               color = colorRampPalette(rev(brewer.pal(11, "RdBu")))(100),
               silent = TRUE)

# After: outlier capped
p2 <- pheatmap(data_capped,
               main = "Capped at Â±2.5 SD: Patterns visible",
               color = colorRampPalette(rev(brewer.pal(11, "RdBu")))(100),
               breaks = seq(-2.5, 2.5, length.out = 101),
               silent = TRUE)

grid.arrange(p1[[4]], p2[[4]], ncol = 2)
```

## Color Scale Considerations

::: {.callout-important}
## Critical Elements

1. **Always include color scale bar** with numeric labels
2. **Center at meaningful value** (often zero for diverging data)
3. **Label extremes if capped**: "<-2.5" or ">+2.5"
4. **Use appropriate palette**:
   - Diverging for data with meaningful zero (red-white-blue)
   - Sequential for one-directional (viridis)
:::

## Recommendations

::: {.callout-tip}
## Best Practices

1. **Inspect data distribution** before making heatmap
2. **Cap at 2-3 SD** for large datasets with outliers
3. **Use quantiles** (5-95%) for robustness
4. **Always annotate** what you did: "Values capped at Â±3 SD"
5. **Include color scale** with actual values
6. **Scale data BEFORE** passing to heatmap function
7. **Calculate dendrograms** on the same scaled data
8. **Consider `massageR::heat.clust()`** for automatic proper scaling workflow
:::
