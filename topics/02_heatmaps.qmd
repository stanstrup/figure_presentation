# Heatmap Scaling {background-color="#e67e22"}

## The Outlier Problem

**Scenario**: Gene expression data

- 99% of values: -2 to +2
- 1 outlier gene: +20

::: {.fragment}
**What happens with default scaling?**

Color scale: -20 to +20

Result: Everything looks the same color! ðŸ˜±
:::

## Visual Example

```{r}
#| label: heatmap-outlier-example
#| echo: true
#| eval: true

# Simulate data with outlier
set.seed(123)
expr_matrix <- matrix(rnorm(100, mean = 0, sd = 1), nrow = 10)
expr_matrix[5, 5] <- 20  # One extreme outlier

# Default heatmap - terrible!
library(pheatmap)
pheatmap(expr_matrix)  # All data compressed to narrow range
```

::: {.fragment}
99% of your data is invisible due to 1 outlier!
:::

## The Problem Illustrated

::: {.columns}
::: {.column width="50%"}
**Without Outlier Handling**

- Scale: -20 to +20
- Most data: -2 to +2
- Uses only 20% of color range
- Real patterns invisible
:::

::: {.column width="50%"}
**With Proper Scaling**

- Scale: -3 to +3 (capped)
- Most data: -2 to +2
- Uses 100% of color range
- Patterns visible!
:::
:::

## The Dendrogram Scaling Trap

::: {.callout-warning}
## Hidden Technical Issue

**Critical R bug**: Functions like `heatmap()`, `heatmap.2()`, and `heatplot()` have a dangerous inconsistency:

- The `scale` parameter affects **color visualization**
- But **NOT** dendrogram calculation!

**Result**: Dendrograms cluster on unscaled data while colors show scaled data!
:::

## Why This Matters

```{r}
#| label: heatmap-scale-issue
#| echo: true
#| eval: true

library(gplots)  # or source the function

# This looks correct but is misleading!
heatmap.2(expr_matrix, scale = "column")

# Dendrograms calculated on RAW data
# Colors displayed on SCALED data
# Clustering doesn't match what you see!
```

## The Correct Approach: heat.clust

```{r}
#| label: heat-clust-example
#| echo: true
#| eval: true

library(massageR)

# Pre-scale data AND calculate dendrograms on scaled data
z <- heat.clust(expr_matrix,
                scaledim = "column",  # Scale by column
                zlim = c(-3, 3),      # Cap at Â±3
                reorder = c("column", "row"))

# Now pass pre-computed dendrograms
heatmap.2(z$data,
          Rowv = z$Rowv,
          Colv = z$Colv,
          scale = "none")  # Already scaled!

# Dendrograms and colors now consistent!
```

Source: [stanstrup.github.io/heatmaps.html](https://stanstrup.github.io/heatmaps.html)

## Solution 1: Standard Deviation Cutoffs

```{r}
#| label: sd-cutoff
#| echo: true
#| eval: true
#| code-line-numbers: "|2-3|5-6"

# Cap at Â±2 SD
mean_val <- mean(expr_matrix, na.rm = TRUE)
sd_val <- sd(expr_matrix, na.rm = TRUE)

expr_capped <- pmin(pmax(expr_matrix, mean_val - 2*sd_val),
                    mean_val + 2*sd_val)

pheatmap(expr_capped,
         main = "Values capped at Â±2 SD")
```

Most common: Â±2 or Â±3 SD cutoff

## Solution 2: Quantile-Based

```{r}
#| label: quantile-cutoff
#| echo: true
#| eval: true

# Cap at 5th and 95th percentiles
lower <- quantile(expr_matrix, 0.05, na.rm = TRUE)
upper <- quantile(expr_matrix, 0.95, na.rm = TRUE)

expr_capped <- pmin(pmax(expr_matrix, lower), upper)

pheatmap(expr_capped,
         main = "Values capped at 5-95 percentiles")
```

Robust to extreme outliers

## Solution 3: Manual Breaks

```{r}
#| label: manual-breaks
#| echo: true
#| eval: true

# Define your own color breaks
breaks <- seq(-3, 3, length.out = 100)

pheatmap(expr_matrix,
         breaks = breaks,
         main = "Custom breaks: -3 to +3")

# Values outside range automatically assigned to extremes
```

Full control over color mapping

## Solution 4: Log Transformation

**For positive values only** (e.g., counts, intensities)

```{r}
#| label: log-transform
#| echo: true
#| eval: true

# Log transform data
expr_log <- log10(expr_matrix + 1)  # +1 to handle zeros

pheatmap(expr_log,
         main = "Log10 transformed")

# Or with ggplot2
ggplot(heatmap_df, aes(x, y, fill = value)) +
  geom_tile() +
  scale_fill_viridis_c(trans = "log10")
```

## Annotating Capped Values

**Best practice**: Indicate when values are capped

```{r}
#| label: annotate-capped
#| echo: true
#| eval: true

library(ComplexHeatmap)

# Create annotation for outliers
outliers <- expr_matrix > 3 | expr_matrix < -3

Heatmap(expr_capped,
        name = "Expression",
        cell_fun = function(j, i, x, y, width, height, fill) {
          if(outliers[i, j]) {
            grid.text("*", x, y)  # Mark outliers with asterisk
          }
        })
```

## Color Scale Considerations

::: {.callout-important}
## Critical Elements

1. **Always include color scale bar** with numeric labels
2. **Center at meaningful value** (often zero for diverging data)
3. **Label extremes if capped**: "<-2 SD" or ">+3"
4. **Use appropriate palette**:
   - Diverging for data with meaningful zero (red-white-blue)
   - Sequential for one-directional (viridis)
:::

## Diverging Scales for Centered Data

```{r}
#| label: diverging-scale
#| echo: true
#| eval: true

# When zero is meaningful (fold-change, difference, etc.)
library(RColorBrewer)

pheatmap(expr_capped,
         color = colorRampPalette(
           brewer.pal(11, "RdBu")
         )(100),
         breaks = seq(-3, 3, length.out = 101))

# Zero = white, negative = blue, positive = red
```

## Real-World Example

```{r}
#| label: rnaseq-example
#| echo: true
#| eval: true

# RNA-seq data
library(DESeq2)

# Log fold changes: often have outliers
# Cap at Â±4 for visualization
results$log2FC_capped <- pmin(pmax(results$log2FoldChange, -4), 4)

# Make heatmap
library(ComplexHeatmap)
Heatmap(log2FC_capped,
        col = circlize::colorRamp2(
          c(-4, 0, 4),
          c("blue", "white", "red")
        ),
        heatmap_legend_param = list(
          title = "log2 FC",
          at = c(-4, -2, 0, 2, 4),
          labels = c("â‰¤-4", "-2", "0", "2", "â‰¥4")
        ))
```

## When NOT to Cap

::: {.callout-warning}
## Don't cap blindly!

- If outliers are **biologically meaningful** (rare events)
- Small datasets where each value matters
- When you want to highlight extreme values

**Alternative**: Use asterisks or separate panel for outliers
:::

## Recommendations

::: {.callout-tip}
## Best Practices

1. **Inspect data distribution** before making heatmap
2. **Cap at 2-3 SD** for large datasets with outliers
3. **Use quantiles** (5-95%) for robustness
4. **Always annotate** what you did: "Values capped at Â±2 SD"
5. **Include color scale** with actual values
6. **Test different scales** to ensure you're not hiding real patterns
:::

## Comparison: Before and After

```{r}
#| label: heatmap-comparison
#| echo: true
#| eval: true

library(patchwork)

# Before: with outlier
p1 <- pheatmap(expr_matrix, main = "Uncapped: Pattern lost", silent = TRUE)

# After: outlier capped
p2 <- pheatmap(expr_capped, main = "Capped at Â±2 SD", silent = TRUE)

# Side-by-side comparison
p1[[4]] | p2[[4]]
```
