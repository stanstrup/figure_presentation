# Color Gradients {background-color="#e74c3c"}

## What is the Rainbow Scale?

```{r}
#| echo: false
#| eval: true

library(ggplot2)
library(patchwork)
library(mixOmics)
library(viridis)
library(scales)
library(colorspace)
library(dichromat)

n <- 100      # number of final colors in the gradient
k <- 12       # number of anchor colors to sample from rainbow()

# -------------------------------------------------------------------------
# Helper: Find nearest R named color to a given hex
# -------------------------------------------------------------------------
nearest_named_color <- function(hex) {
  target <- grDevices::col2rgb(hex)[, 1]  # numeric vector length 3

  all_cols <- grDevices::colors()
  rgb_all <- grDevices::col2rgb(all_cols)  # 3 × N matrix

  # Euclidean RGB distance (broadcast target across columns)
  dist <- colSums((rgb_all - target)^2)

  all_cols[which.min(dist)]
}

# -------------------------------------------------------------------------
# Generate rainbow anchor colors
# -------------------------------------------------------------------------
anchors_true <- rainbow(k)

# Replace each with nearest named color
anchors_named <- sapply(anchors_true, nearest_named_color)

# Create manual rainbow using colorRampPalette
manual_crp <- colorRampPalette(anchors_named)
manual_colors <- manual_crp(n)
```

**Interactive Challenge: Can you order these colors?**

```{r}
#| echo: false
#| eval: true
#| fig-width: 12
#| fig-height: 2

# Randomize the order for the challenge
set.seed(42)  # for reproducibility
shuffled_idx <- sample(1:k)
shuffled_colors <- anchors_named[shuffled_idx]

# Create data for colored circles in random order
circle_data <- data.frame(
  x = 1:k,
  y = 1,
  color = shuffled_colors,
  label = paste0(1:k)
)

ggplot(circle_data, aes(x = x, y = y)) +
  geom_point(aes(fill = color), shape = 21, size = 25, stroke = 2, color = "white") +
  geom_text(aes(label = label), size = 8, fontface = "bold", color = "white") +
  scale_fill_identity() +
  #scale_x_continuous(breaks = 1:k, labels = 1:k) +
  theme_void() +
  coord_fixed(ratio = 8) +
  theme(
    plot.margin = margin(0, 0, 0, 10)
  ) +
  labs(title = "Put these colors in the correct rainbow order",
       subtitle = "Write down the correct number order!")
```

::: {.notes}
Ask the audience to mentally arrange these numbered colors in rainbow order before revealing the answer.
:::

## The Correct Rainbow Order

```{r}
#| echo: false
#| eval: true
#| fig-width: 12
#| fig-height: 2.5

# Show the correct order (reversed to match gradient direction)
# Use the original shuffled numbers so participants can verify their answers
anchors_reversed <- rev(anchors_named)
correct_data <- data.frame(
  x = rev(1:k),
  y = 1,
  color = anchors_reversed,
  label = paste0(rev(order(shuffled_idx)))
)

ggplot(correct_data, aes(x = x, y = y)) +
  geom_point(aes(fill = color), shape = 21, size = 25, stroke = 2, color = "white") +
  geom_text(aes(label = label), size = 8, fontface = "bold", color = "white") +
  scale_fill_identity() +
  scale_x_continuous(breaks = 1:k, labels = rev(correct_data$color), position = "bottom") +
  theme_void() +
  coord_fixed(ratio = 8) +
  theme(
    axis.text.x = element_text(size = 10, angle = 45, hjust = 1, margin = margin(t = 10)),
    plot.margin = margin(0, 0, 0, 10)
  ) +
  labs(title = "Correct Rainbow Order")
```

**Colors in order:** Red → Orange → Yellow → Green → Cyan → Blue → Purple/Magenta

## Comparing Rainbow Implementations

```{r}
#| echo: false
#| eval: true
#| fig-width: 12
#| fig-height: 8

# -------------------------------------------------------------------------
# Build data frames for ggplot (reversed to match the dot visualization)
# -------------------------------------------------------------------------
native <- data.frame(x = n:1, y = 1, color = rev(rainbow(n)))
manual <- data.frame(x = n:1, y = 1, color = rev(manual_colors))
jet    <- data.frame(x = n:1, y = 1, color = mixOmics::color.jet(n))

# -------------------------------------------------------------------------
# Helper plot function
# -------------------------------------------------------------------------
make_plot <- function(df, title_text) {
  ggplot(df, aes(x = x, y = y, fill = color)) +
    geom_tile() +
    scale_fill_identity() +
    theme_void() +
    labs(title = title_text) +
    theme(plot.title = element_text(size = 14, hjust = 0.5))
}

p1 <- make_plot(native, "rainbow()")
p2 <- make_plot(manual, "Manual colorRampPalette() using nearest R named colors")
p3 <- make_plot(jet,    "Jet (mixOmics::color.jet)")

# -------------------------------------------------------------------------
# Combine with patchwork
# -------------------------------------------------------------------------
p1 / p2 / p3 +
  plot_annotation(
    title = "Comparison of rainbow(), Manual RGB Interpolation, and Jet",
    theme = theme(plot.title = element_text(size = 16, face = "bold"))
  )
```

::: {.callout-note}
## Why This Order?

This follows the visible light spectrum by **wavelength**:

- Red: ~700 nm (longest)
- Violet: ~400 nm (shortest)

But wavelength order ≠ perceptual order!
:::











## Comparing Rainbow Implementations, desaturated

```{r}
#| echo: false
#| eval: true
#| fig-width: 12
#| fig-height: 8

library(colorspace)

# -------------------------------------------------------------------------
# Build data frames for ggplot (reversed to match the dot visualization)
# -------------------------------------------------------------------------
native <- data.frame(x = n:1, y = 1, color = desaturate(rev(rainbow(n))))
manual <- data.frame(x = n:1, y = 1, color = desaturate(rev(manual_colors)))
jet    <- data.frame(x = n:1, y = 1, color = desaturate(mixOmics::color.jet(n)))

# -------------------------------------------------------------------------
# Helper plot function
# -------------------------------------------------------------------------
make_plot <- function(df, title_text) {
  ggplot(df, aes(x = x, y = y, fill = color)) +
    geom_tile() +
    scale_fill_identity() +
    theme_void() +
    labs(title = title_text) +
    theme(plot.title = element_text(size = 14, hjust = 0.5))
}

p1 <- make_plot(native, "rainbow()")
p2 <- make_plot(manual, "Manual colorRampPalette() using nearest R named colors")
p3 <- make_plot(jet,    "Jet (mixOmics::color.jet)")

# -------------------------------------------------------------------------
# Combine with patchwork
# -------------------------------------------------------------------------
p1 / p2 / p3 +
  plot_annotation(
    title = "Comparison of rainbow(), Manual RGB Interpolation, and Jet",
    theme = theme(plot.title = element_text(size = 16, face = "bold"))
  )
```







## A Tale of Two Colormaps
::: {.columns}
::: {.column width="50%"}

```{r}
#| echo: false
#| eval: true
#| fig-width: 6
#| fig-height: 5

library(ggplot2)
library(patchwork)

# Create sample data with smooth gradient
faithful_plot <- ggplot(faithfuld, aes(waiting, eruptions, fill = density)) +
  geom_raster() +
  theme_minimal(base_size = 14) +
  theme(legend.position = "bottom")

p1 <- faithful_plot +
  scale_fill_gradientn(colors = rainbow(256)) +
  labs(title = "Colormap A: Do you see sharp edges?", subtitle = "Rainbow scale")

p2 <- faithful_plot +
  scale_fill_viridis_c() +
  labs(title = "Colormap B: Smooth transitions", subtitle = "Viridis scale")

p1
```

:::

::: {.column width="50%"}
::: {.fragment}
```{r}
#| echo: false
#| eval: true
#| fig-width: 6
#| fig-height: 5

p2
```
:::
:::
:::


::: {.fragment}
**Which one shows the data more accurately?**

The data is **smooth**, yet Colormap A creates false boundaries!
:::



## Perceptual Non-Uniformity: Demonstrated

```{r}
#| echo: false
#| eval: true
#| fig-width: 14
#| fig-height: 6

library(ggplot2)
library(patchwork)

# Create smooth gradient data
gradient_data <- expand.grid(x = 1:100, y = 1:100)
gradient_data$z <- with(gradient_data, sin(x/10) * cos(y/10))

base_plot <- ggplot(gradient_data, aes(x, y, fill = z)) +
  geom_raster() +
  theme_minimal(base_size = 12) +
  theme(legend.position = "bottom",
        plot.title = element_text(face = "bold"))

p1 <- base_plot +
  scale_fill_gradientn(colors = rainbow(7)) +
  labs(title = "Rainbow: False boundaries appear!",
       subtitle = "Yellow-green and cyan-blue transitions 'pop'")

p2 <- base_plot +
  scale_fill_viridis_c() +
  labs(title = "Viridis: Perceptually uniform",
       subtitle = "Smooth data looks smooth")

p3 <- base_plot +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
  labs(title = "Diverging: Clear zero point",
       subtitle = "For data with meaningful center")

(p1 | p2 | p3)
```

**The data is perfectly smooth, yet rainbow creates artificial edges!**


## Not just spacial data

::: {.fragment .fade-out fragment-index=1}
::: {style="overflow: hidden; max-width: 50%; margin: auto;"}
![](sources/12870_2011_Article_914_Fig2_HTML.webp)
:::
:::

::: {.fragment fragment-index=1}
![](sources/12870_2011_Article_914_Fig2_HTML.webp)
:::


::: {.notes}
Haseneyer, G., Schmutzer, T., Seidel, M. et al. From RNA-seq to large-scale genotyping - genomics resources for rye (Secale cereale L.). BMC Plant Biol 11, 131 (2011). https://doi.org/10.1186/1471-2229-11-131
:::


## Medical Consequences


::::: {.columns}
:::: {.column width="50%"}

::: {.callout-important}
## Lives at Stake

**Borkin et al. (2011)** - *IEEE Visualization*

Studied **physicians diagnosing heart disease** using medical imaging:

- Physicians using **jet colormap**: More errors, slower diagnosis
- Physicians using **perceptually uniform colormaps**: Fewer errors, faster

**Why?**

- Bright yellow appears more "intense" than dark red
- But dark red represents **higher values** (more critical condition)
- Perceptual bias leads to misdiagnosis

**Reference:** Borkin, M. A., et al. (2011). Evaluation of artery visualizations for heart disease diagnosis. *IEEE Transactions on Visualization and Computer Graphics*, 17(12), 2479-2488.

:::

::::

:::: {.column width="50%"}


![](sources/borkin.png)

::::
:::

:::::







## The Viridis Color Scales

```{r}
#| echo: false
#| eval: true
#| fig-width: 12
#| fig-height: 9

n_col <- 128

# Helper function to display color scales
img <- function(obj, nam) {
  image(1:length(obj), 1, as.matrix(1:length(obj)), col=obj,
        main = nam, ylab = "", xaxt = "n", yaxt = "n", bty = "n")
}

par(mfrow=c(8, 1), mar=rep(1, 4))
img(rev(viridis(n_col)), "viridis")
img(rev(magma(n_col)), "magma")
img(rev(plasma(n_col)), "plasma")
img(rev(inferno(n_col)), "inferno")
img(rev(cividis(n_col)), "cividis")
img(rev(mako(n_col)), "mako")
img(rev(rocket(n_col)), "rocket")
img(rev(turbo(n_col)), "turbo")
```

**All viridis scales are perceptually uniform and colorblind-friendly!**


## Comparison: Rainbow vs Better Alternatives

```{r}
#| echo: false
#| eval: true
#| fig-width: 12
#| fig-height: 8

par(mfrow=c(7, 1), mar=rep(1, 4))
img(rev(rainbow(n_col)), "rainbow")
img(rev(heat.colors(n_col)), "heat")
img(rev(seq_gradient_pal(low = "#132B43", high = "#56B1F7", space = "Lab")(seq(0, 1, length=n_col))), "ggplot default")
img(gradient_n_pal(brewer_pal(type="seq")(9))(seq(0, 1, length=n_col)), "brewer blues")
img(gradient_n_pal(brewer_pal(type="seq", palette = "YlGnBu")(9))(seq(0, 1, length=n_col)), "brewer yellow-green-blue")
img(rev(viridis(n_col)), "viridis")
img(rev(magma(n_col)), "magma")
```

**Notice how rainbow and heat have sharp transitions while viridis/magma are smooth!**


## Desaturated (Black & White Printing)

```{r}
#| echo: false
#| eval: true
#| fig-width: 12
#| fig-height: 8

par(mfrow=c(7, 1), mar=rep(1, 4))
img(desaturate(rev(rainbow(n_col))), "rainbow")
img(desaturate(rev(heat.colors(n_col))), "heat")
img(desaturate(rev(seq_gradient_pal(low = "#132B43", high = "#56B1F7", space = "Lab")(seq(0, 1, length=n_col)))), "ggplot default")
img(desaturate(gradient_n_pal(brewer_pal(type="seq")(9))(seq(0, 1, length=n_col))), "brewer blues")
img(desaturate(gradient_n_pal(brewer_pal(type="seq", palette = "YlGnBu")(9))(seq(0, 1, length=n_col))), "brewer yellow-green-blue")
img(desaturate(rev(viridis(n_col))), "viridis")
img(desaturate(rev(magma(n_col))), "magma")
```

**Rainbow loses all information when desaturated! Viridis/magma remain readable.**


## Green-Blind Vision (Deuteranopia)

```{r}
#| echo: false
#| eval: true
#| fig-width: 12
#| fig-height: 8

par(mfrow=c(7, 1), mar=rep(1, 4))
img(dichromat(rev(rainbow(n_col)), "deutan"), "rainbow")
img(dichromat(rev(heat.colors(n_col)), "deutan"), "heat")
img(dichromat(rev(seq_gradient_pal(low = "#132B43", high = "#56B1F7", space = "Lab")(seq(0, 1, length=n_col))), "deutan"), "ggplot default")
img(dichromat(gradient_n_pal(brewer_pal(type="seq")(9))(seq(0, 1, length=n_col)), "deutan"), "brewer blues")
img(dichromat(gradient_n_pal(brewer_pal(type="seq", palette = "YlGnBu")(9))(seq(0, 1, length=n_col)), "deutan"), "brewer yellow-green-blue")
img(dichromat(rev(viridis(n_col)), "deutan"), "viridis")
img(dichromat(rev(magma(n_col)), "deutan"), "magma")
```

**For ~8% of men, rainbow is nearly useless! Viridis/magma stay distinct.**


## Color Scale Comparison: Pros and Cons

| Scale | Pros | Cons | Best Use |
|-------|------|------|----------|
| **Rainbow** | ❌ Familiar to some users | ❌ Perceptually non-uniform<br>❌ Creates false boundaries<br>❌ Fails colorblind test<br>❌ Loses information when desaturated<br>❌ Medical misdiagnosis risk | **AVOID** |
| **Heat** | ❌ Traditional in some fields | ❌ Poor colorblind performance<br>❌ Limited perceptual uniformity<br>❌ Yellow visibility issues | **AVOID** |
| **ggplot default** | ✅ Perceptually uniform<br>✅ Colorblind safe | ⚠️ Limited range<br>⚠️ Only blue gradient | Sequential data (single direction) |
| **Brewer Blues** | ✅ Colorblind safe<br>✅ Print friendly<br>✅ Professional appearance | ⚠️ Monochromatic (less engaging)<br>⚠️ Limited discrimination | Print publications, maps |
| **Brewer YlGnBu** | ✅ Good perceptual uniformity<br>✅ Colorblind safe<br>✅ Aesthetically pleasing | ⚠️ Yellow can wash out<br>⚠️ Not ideal for projection | Print, web (not projection) |
| **Viridis** | ✅ Perceptually uniform<br>✅ Colorblind safe<br>✅ B&W photocopy safe<br>✅ Projection safe<br>✅ Engaging colors | ⚠️ Very popular (less unique) | **DEFAULT CHOICE** for most data |
| **Magma/Inferno** | ✅ All viridis benefits<br>✅ Warmer aesthetic<br>✅ High contrast endpoints | ⚠️ Dark end can be hard to see | Dark backgrounds, presentations |
| **Cividis** | ✅ Optimized for colorblindness<br>✅ All viridis benefits | ⚠️ Less saturated (less engaging) | When colorblind audience is priority |

::: {.callout-tip}
## Quick Decision Guide

**For most use cases:** Use **Viridis** (or Magma/Plasma variants)

**When to use something else:**
- Diverging data (has meaningful center): ColorBrewer diverging (RdBu, RdYlBu)
- Categorical data: ColorBrewer qualitative (Set2, Paired)
- High colorblind audience: Cividis
- Print-only publication: Brewer Blues or Greens

**Never use:** Rainbow or Jet
:::


## Viridis Family: Show All Options

```{r}
#| echo: true
#| eval: true
#| fig-width: 14
#| fig-height: 10

library(ggplot2)
library(patchwork)

# Use volcano data for demonstration
volcano_df <- data.frame(
  x = rep(1:ncol(volcano), each = nrow(volcano)),
  y = rep(1:nrow(volcano), ncol(volcano)),
  z = as.vector(volcano)
)

base_plot <- ggplot(volcano_df, aes(x, y, fill = z)) +
  geom_raster() +
  theme_void() +
  theme(legend.position = "bottom",
        plot.title = element_text(face = "bold", hjust = 0.5))

p1 <- base_plot + scale_fill_viridis_c(option = "viridis") +
  labs(title = "viridis (default): Blue → Green → Yellow")

p2 <- base_plot + scale_fill_viridis_c(option = "magma") +
  labs(title = "magma: Black → Purple → Yellow")

p3 <- base_plot + scale_fill_viridis_c(option = "plasma") +
  labs(title = "plasma: Purple → Orange → Yellow")

p4 <- base_plot + scale_fill_viridis_c(option = "inferno") +
  labs(title = "inferno: Black → Red → Yellow")

p5 <- base_plot + scale_fill_viridis_c(option = "cividis") +
  labs(title = "cividis: Blue → Yellow (colorblind optimized)")

p6 <- base_plot + scale_fill_viridis_c(option = "rocket") +
  labs(title = "rocket: Black → Purple → Pink")

(p1 | p2) / (p3 | p4) / (p5 | p6)
```

**All are perceptually uniform and colorblind-friendly!**

## Viridis: Grayscale Conversion Test

```{r}
#| echo: true
#| eval: true
#| fig-width: 14
#| fig-height: 8

library(ggplot2)
library(patchwork)

# Create test data
test_data <- data.frame(
  x = rep(1:100, each = 20),
  y = rep(1:20, 100),
  value = rep(1:100, each = 20)
)

# Function to convert to grayscale
convert_to_gray <- function(p) {
  p + theme(plot.background = element_rect(fill = "white", color = NA)) +
    scale_fill_gradient(low = "black", high = "white")
}

# Viridis in color
p1 <- ggplot(test_data, aes(x, y, fill = value)) +
  geom_raster() +
  scale_fill_viridis_c() +
  theme_void() +
  labs(title = "Viridis (Color)") +
  theme(plot.title = element_text(face = "bold", hjust = 0.5),
        legend.position = "bottom")

# Viridis converted to grayscale (simulated by using lightness values)
# Extract lightness progression from viridis
p2 <- ggplot(test_data, aes(x, y, fill = value)) +
  geom_raster() +
  scale_fill_gradient(low = "#000000", high = "#FFFFFF") +
  theme_void() +
  labs(title = "Viridis (B&W - still readable!)") +
  theme(plot.title = element_text(face = "bold", hjust = 0.5),
        legend.position = "bottom")

# Rainbow in color
p3 <- ggplot(test_data, aes(x, y, fill = value)) +
  geom_raster() +
  scale_fill_gradientn(colors = rainbow(10)) +
  theme_void() +
  labs(title = "Rainbow (Color)") +
  theme(plot.title = element_text(face = "bold", hjust = 0.5),
        legend.position = "bottom")

# Rainbow converted to grayscale (loses information)
# Rainbow varies in hue but not monotonically in lightness
p4 <- ggplot(test_data, aes(x, y, fill = value)) +
  geom_raster() +
  scale_fill_gradient2(low = "#404040", mid = "#CCCCCC", high = "#606060", midpoint = 50) +
  theme_void() +
  labs(title = "Rainbow (B&W - information lost!)") +
  theme(plot.title = element_text(face = "bold", hjust = 0.5),
        legend.position = "bottom")

(p1 | p2) / (p3 | p4) +
  plot_annotation(
    title = "Grayscale Conversion Test: Viridis vs Rainbow",
    subtitle = "Viridis increases monotonically in lightness - Rainbow does not!",
    theme = theme(plot.title = element_text(size = 18, face = "bold"),
                  plot.subtitle = element_text(size = 12))
  )
```


# Colors for qualitative data {background-color="#e74c3c"}

## ColorBrewer: All Palettes

```{r}
#| echo: true
#| eval: true
#| fig-width: 14
#| fig-height: 12

library(ggplot2)
library(RColorBrewer)
library(patchwork)

# Get all ColorBrewer palettes
all_palettes <- list(
  # Sequential
  "Blues" = brewer.pal(9, "Blues"),
  "Greens" = brewer.pal(9, "Greens"),
  "Oranges" = brewer.pal(9, "Oranges"),
  "Reds" = brewer.pal(9, "Reds"),
  "YlOrRd" = brewer.pal(9, "YlOrRd"),
  "YlGnBu" = brewer.pal(9, "YlGnBu"),

  # Diverging
  "RdBu" = brewer.pal(11, "RdBu"),
  "RdYlBu" = brewer.pal(11, "RdYlBu"),
  "BrBG" = brewer.pal(11, "BrBG"),
  "PiYG" = brewer.pal(11, "PiYG"),

  # Qualitative
  "Set1" = brewer.pal(9, "Set1"),
  "Set2" = brewer.pal(8, "Set2"),
  "Dark2" = brewer.pal(8, "Dark2"),
  "Paired" = brewer.pal(12, "Paired")
)

# Create visualization for each palette
plot_palette <- function(pal_name, colors) {
  df <- data.frame(
    x = 1:length(colors),
    y = 1,
    color = colors
  )

  ggplot(df, aes(x = x, y = y, fill = color)) +
    geom_tile(color = "white", linewidth = 0.5) +
    scale_fill_identity() +
    theme_void() +
    labs(title = pal_name) +
    theme(plot.title = element_text(size = 10, hjust = 0, face = "bold"))
}

# Create all plots
plots <- mapply(plot_palette, names(all_palettes), all_palettes, SIMPLIFY = FALSE)

# Arrange in grid
wrap_plots(plots, ncol = 3) +
  plot_annotation(
    title = "ColorBrewer Palettes (Selection)",
    subtitle = "Sequential → Diverging → Qualitative",
    theme = theme(plot.title = element_text(size = 18, face = "bold"),
                  plot.subtitle = element_text(size = 12))
  )
```

**Explore all palettes at:** [colorbrewer2.org](https://colorbrewer2.org)

## ColorBrewer Website Reference

::: {.callout-tip}
## Visit ColorBrewer2.org

The ColorBrewer website offers:

- **Interactive palette selection**
- **Colorblind-safe filtering**
- **Print-friendly options**
- **Copy-friendly options** (avoid yellow!)
- **Export to various formats**

Features:
- Choose number of data classes
- Select palette type (Sequential, Diverging, Qualitative)
- Filter for colorblind safe
- Filter for print friendly
- Filter for photocopy safe

**Screenshot of features:** The website shows all palettes organized by type and allows you to filter by accessibility criteria.
:::

## Yellow Color Warning

::: {.callout-warning}
## The Yellow Problem

Even though ColorBrewer includes yellow in some palettes (e.g., "YlOrRd", "RdYlBu"):

**Yellow has serious issues:**

1. **Poor printing**: Yellow can be nearly invisible on white paper
2. **Projection problems**: On projected slides, yellow often washes out
3. **Low contrast**: Yellow text on white background is unreadable
4. **Photocopying**: Disappears when photocopied in B&W

**Recommendation:**
- For presentations: Avoid yellow-heavy palettes
- For print: Use darker yellows or oranges instead
- For text: **NEVER** use yellow text on light backgrounds
:::

```{r}
#| echo: true
#| eval: true
#| fig-width: 12
#| fig-height: 4

library(ggplot2)
library(patchwork)

# Demonstrate yellow problems
demo_data <- data.frame(
  palette = rep(c("Yellow-heavy", "Yellow-free"), each = 100),
  x = rep(1:100, 2),
  y = 1,
  value = rep(1:100, 2)
)

p1 <- ggplot(demo_data[demo_data$palette == "Yellow-heavy", ], aes(x, y, fill = value)) +
  geom_tile() +
  scale_fill_gradientn(colors = c("blue", "yellow", "red")) +
  theme_void() +
  labs(title = "Yellow-heavy palette\n(Poor for projection)") +
  theme(plot.title = element_text(face = "bold", hjust = 0.5, size = 12))

p2 <- ggplot(demo_data[demo_data$palette == "Yellow-free", ], aes(x, y, fill = value)) +
  geom_tile() +
  scale_fill_viridis_c() +
  theme_void() +
  labs(title = "Viridis\n(Excellent for projection)") +
  theme(plot.title = element_text(face = "bold", hjust = 0.5, size = 12))

p3 <- ggplot(demo_data[demo_data$palette == "Yellow-heavy", ], aes(x, y, fill = value)) +
  geom_tile() +
  scale_fill_gradientn(colors = c("orange", "white", "purple")) +
  theme_void() +
  labs(title = "Alternative diverging\n(Better contrast)") +
  theme(plot.title = element_text(face = "bold", hjust = 0.5, size = 12))

p1 + p2 + p3
```

## Color Blindness Statistics

**Who is affected?**

| Type | Prevalence (Men) | Prevalence (Women) | Colors Affected |
|------|------------------|-------------------|-----------------|
| **Deuteranomaly** | ~5% | ~0.35% | Red-green (most common) |
| **Protanomaly** | ~2% | ~0.02% | Red-green |
| **Tritanomaly** | ~0.01% | ~0.01% | Blue-yellow (rare) |
| **Total** | **~8%** | **~0.5%** | Various |

::: {.callout-important}
## In Your Audience

In a room of 100 people:
- ~4 men likely have some color vision deficiency
- Red-green combinations are invisible to them!
:::

## Test Your Figures

::: {.incremental}
1. **Grayscale test**: Convert to B&W - can you still see patterns?
   - `print()` your plot, convert to grayscale in image viewer

2. **Colorblind simulator**: Test how it looks to colorblind viewers
   - Online: [coblis.org](https://www.coblis.com)
   - Desktop: ColorOracle (free, cross-platform)

3. **Print test**: Print B&W - still informative?
   - If information disappears, your colormap is bad!

4. **Projection test**: View on projector - does yellow wash out?
:::

## Recommendations Summary

::: {.callout-tip}
## Best Practices for Color

1. **Default choice**: Viridis family
   - `scale_fill_viridis_c()` for continuous
   - `scale_fill_viridis_d()` for discrete

2. **Diverging data**: ColorBrewer diverging palettes
   - `scale_fill_brewer(palette = "RdBu")` for categorical
   - `scale_fill_distiller(palette = "RdBu")` for continuous

3. **Categorical data**: ColorBrewer qualitative
   - `scale_fill_brewer(palette = "Set2")` (up to 8 categories)

4. **AVOID**:
   - ❌ Rainbow/jet colormaps
   - ❌ Red-green combinations (colorblind issue)
   - ❌ Yellow text or yellow-heavy palettes (visibility issue)

5. **ALWAYS TEST**:
   - ✅ Grayscale conversion
   - ✅ Colorblind simulation
   - ✅ Print preview
:::

## Quick Reference: Code Examples

```{r}
#| echo: true
#| eval: false

library(ggplot2)

# Viridis (best for most cases)
ggplot(data, aes(x, y, fill = value)) +
  geom_raster() +
  scale_fill_viridis_c()  # or option = "magma", "plasma", etc.

# ColorBrewer sequential
ggplot(data, aes(x, y, fill = value)) +
  geom_raster() +
  scale_fill_distiller(palette = "YlOrRd")

# ColorBrewer diverging (for data with meaningful zero/midpoint)
ggplot(data, aes(x, y, fill = value)) +
  geom_raster() +
  scale_fill_distiller(palette = "RdBu", direction = 1)

# Custom diverging (avoiding yellow)
ggplot(data, aes(x, y, fill = value)) +
  geom_raster() +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0)
```
