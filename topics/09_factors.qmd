# Factor Ordering {background-color="#2980b9"}

```{r}
#| label: setup-factors
#| echo: false
#| eval: true
#| message: false

library(ggplot2)
library(dplyr)
library(forcats)

# Set default theme for all plots
theme_set(theme_bw())
```

## The Problem: Alphabetical Ordering

::: {.columns}
::: {.column width="50%"}

```{r}
#| label: factors-problem-alphabetical
#| echo: true
#| eval: true

# Create data with logical categories
category_df <- data.frame(
  category = c("Low", "Medium", "High", "Very High", "Low", "High"),
  value = c(10, 20, 15, 30, 12, 25)
)

# R defaults to alphabetical!
p1 <- ggplot(category_df, aes(x = category, y = value)) +
  geom_col(fill = "coral") +
  theme_classic(base_size = 12) +
  labs(title = "Alphabetical (Wrong!)")
```

:::

::: {.column width="50%"}

```{r}
#| label: factors-solution-ordered
#| echo: true
#| eval: true

# Specify levels explicitly
category_df$category <- factor(category_df$category,
                       levels = c("Low", "Medium", "High", "Very High"))

# Now plots use logical order!
p2 <- ggplot(category_df, aes(x = category, y = value)) +
  geom_col(fill = "steelblue") +
  theme_classic(base_size = 12) +
  labs(title = "Logical Order (Correct!)")
```

:::
:::

::: {.columns}
::: {.column width="50%"}

```{r}
#| label: factors-problem-plot
#| echo: false
#| eval: true
#| fig-width: 5
#| fig-height: 3.5

p1
```

Random order makes no sense!

:::

::: {.column width="50%"}

```{r}
#| label: factors-solution-plot
#| echo: false
#| eval: true
#| fig-width: 5
#| fig-height: 3.5

p2
```

Much better - order makes sense!

:::
:::

## Solution: forcats Package

**Part of tidyverse, designed for factor manipulation**

::: {.columns}
::: {.column width="45%"}

```{r}
#| label: factors-forcats-intro
#| echo: true
#| eval: true

library(forcats)

# Reorder car classes by median highway mpg
p <- mpg %>%
  ggplot(aes(x = fct_reorder(class, hwy, median),
             y = hwy)) +
  geom_boxplot(fill = "lightblue") +
  coord_flip() +
  labs(x = "Vehicle Class",
       y = "Highway MPG",
       title = "Ordered by median MPG")
```

Boxplots now ordered by median value!

:::

::: {.column width="55%"}

```{r}
#| label: factors-forcats-intro-plot
#| echo: false
#| eval: true
#| fig-width: 6
#| fig-height: 5

p
```

:::
:::

## fct_reorder(): Order by Another Variable

::: {.columns}
::: {.column width="45%"}

```{r}
#| label: factors-fct-reorder
#| echo: true
#| eval: true

# Order diamond cuts by mean price
p <- diamonds %>%
  group_by(cut) %>%
  summarise(mean_price = mean(price)) %>%
  ggplot(aes(x = fct_reorder(cut, mean_price),
             y = mean_price,
             fill = cut)) +
  geom_col(show.legend = FALSE) +
  coord_flip() +
  labs(x = "Diamond Cut",
       y = "Mean Price ($)",
       title = "Cuts ordered by average price")
```

Bars ordered by length!

:::

::: {.column width="55%"}

```{r}
#| label: factors-fct-reorder-plot
#| echo: false
#| eval: true
#| fig-width: 6
#| fig-height: 5

p
```

:::
:::

## fct_infreq(): Order by Frequency

::: {.columns}
::: {.column width="45%"}

```{r}
#| label: factors-fct-infreq
#| echo: true
#| eval: true

# Order by how common each vehicle class is
p <- ggplot(mpg,
            aes(x = fct_infreq(class))) +
  geom_bar(fill = "steelblue") +
  coord_flip() +
  labs(x = "Vehicle Class",
       y = "Count",
       title = "Most common classes first")
```

Most common category first!

Great for survey data

:::

::: {.column width="55%"}

```{r}
#| label: factors-fct-infreq-plot
#| echo: false
#| eval: true
#| fig-width: 6
#| fig-height: 5

p
```

:::
:::

## fct_inorder(): Order by Appearance

::: {.columns}
::: {.column width="45%"}

```{r}
#| label: factors-fct-inorder
#| echo: true
#| eval: true

# Create data with specific order
treatment_data <- data.frame(
  treatment = c("Control", "Low Dose",
                "Medium Dose", "High Dose",
                "Control", "Low Dose",
                "Medium Dose", "High Dose"),
  response = c(10, 12, 15, 18,
               11, 13, 16, 19)
)

# Keep order as they appear in data
p <- ggplot(treatment_data,
       aes(x = fct_inorder(treatment),
           y = response)) +
  geom_boxplot(fill = "lightblue") +
  labs(x = "Treatment", y = "Response")
```

Preserves the order from your data!

:::

::: {.column width="55%"}

```{r}
#| label: factors-fct-inorder-plot
#| echo: false
#| eval: true
#| fig-width: 6
#| fig-height: 5

p
```

:::
:::

## Natural Sorting: var1, var2, ..., var10

**The problem with alphabetical sorting:**

::: {.columns}
::: {.column width="45%"}

```{r}
#| label: factors-natural-sort-problem
#| echo: true
#| eval: true

# Create data with numbered variables
var_data <- data.frame(
  variable = rep(c("var1", "var2", "var10", "var20"), each = 5),
  value = rnorm(20, mean = rep(c(10, 15, 20, 25), each = 5), sd = 2)
)

# Alphabetical order: var1, var10, var2, var20 (wrong!)
p <- ggplot(var_data, aes(x = variable, y = value)) +
  geom_boxplot(fill = "coral") +
  labs(title = "Alphabetical: var1, var10, var2, var20")
```

:::

::: {.column width="55%"}

```{r}
#| label: factors-natural-sort-problem-plot
#| echo: false
#| eval: true
#| fig-width: 6
#| fig-height: 5

p
```

:::
:::

## Natural Sorting: The Solution

::: {.columns}
::: {.column width="45%"}

```{r}
#| label: factors-natural-sort-solution
#| echo: true
#| eval: true

# Use gtools::mixedsort() for natural/alphanumeric sorting
library(gtools)

var_data$variable <- factor(var_data$variable,
                            levels = mixedsort(unique(var_data$variable)))

# Natural order: var1, var2, var10, var20 (correct!)
p <- ggplot(var_data, aes(x = variable, y = value)) +
  geom_boxplot(fill = "steelblue") +
  labs(title = "Natural sort: var1, var2, var10, var20")
```

**Note:** `forcats::fct_inseq()` only works if entire level is numeric

:::

::: {.column width="55%"}

```{r}
#| label: factors-natural-sort-solution-plot
#| echo: false
#| eval: true
#| fig-width: 6
#| fig-height: 5

p
```

:::
:::

## fct_rev(): Reverse Order

::: {.columns}
::: {.column width="45%"}

```{r}
#| label: factors-fct-rev
#| echo: true
#| eval: true

# Reverse the frequency order
p <- ggplot(mpg, aes(x = fct_rev(fct_infreq(class)))) +
  geom_bar(fill = "coral") +
  coord_flip() +
  labs(x = "Vehicle Class", y = "Count",
       title = "Least common classes first (reversed)")
```

Now least common first instead of most common!

:::

::: {.column width="55%"}

```{r}
#| label: factors-fct-rev-plot
#| echo: false
#| eval: true
#| fig-width: 6
#| fig-height: 5

p
```

:::
:::

## fct_relevel(): Move Specific Levels

::: {.columns}
::: {.column width="45%"}

```{r}
#| label: factors-fct-relevel
#| echo: true
#| eval: true

# Move "Control" to front for treatment groups
treatment_data <- data.frame(
  treatment = c("Low Dose", "High Dose", "Control",
                "Medium Dose", "Low Dose", "Control"),
  response = c(12, 18, 10, 15, 13, 11)
)

p <- treatment_data %>%
  mutate(treatment = fct_relevel(treatment, "Control")) %>%
  ggplot(aes(treatment, response)) +
  geom_boxplot(fill = "lightblue") +
  labs(x = "Treatment", y = "Response")
```

Control always shown first

Common in experimental data!

:::

::: {.column width="55%"}

```{r}
#| label: factors-fct-relevel-plot
#| echo: false
#| eval: true
#| fig-width: 6
#| fig-height: 5

p
```

:::
:::

## Facet Ordering

::: {.columns}
::: {.column width="45%"}

```{r}
#| label: factors-facet-ordering
#| echo: true
#| eval: true

# Order facets by median highway mpg for each vehicle class
p <- mpg %>%
  filter(class %in% c("compact", "midsize", "suv")) %>%
  mutate(class = fct_reorder(class, hwy, median)) %>%
  ggplot(aes(x = displ, y = hwy)) +
  geom_point(color = "steelblue", alpha = 0.6) +
  facet_wrap(~class) +
  labs(x = "Engine Displacement (L)", y = "Highway MPG")
```

Facet panels in meaningful order!

:::

::: {.column width="55%"}

```{r}
#| label: factors-facet-ordering-plot
#| echo: false
#| eval: true
#| fig-width: 6
#| fig-height: 5

p
```

:::
:::

## ⚠️ The Danger of Numeric Factors

**Converting between factor and numeric can destroy your data!**

\

::: {.fragment}
::: {.columns}
::: {.column width="50%"}

```{r}
#| label: factors-numeric-danger-1
#| echo: true
#| eval: true

# Original numeric data
doses <- c(10, 20, 50, 100, 200)
print(doses)
```

:::

::: {.column width="50%"}

```{r}
#| label: factors-numeric-danger-1b
#| echo: true
#| eval: true

# Convert to factor (common in data import!)
dose_factor <- factor(doses)
print(dose_factor)
```

:::
:::
:::

\

::: {.fragment}
```{r}
#| label: factors-numeric-danger-1c
#| echo: true
#| eval: true

# Looks fine, right? But look at the internal structure:
str(dose_factor)
# Levels: "10" "100" "20" "200" "50" (alphabetical!)
```
:::

\

::: {.fragment}
::: {.columns}
::: {.column width="50%"}

```{r}
#| label: factors-numeric-danger-2
#| echo: true
#| eval: true

# Try to convert back to numeric - WRONG!
as.numeric(dose_factor)
# Returns: 1 3 5 4 2 (NOT original!)
```

:::

::: {.column width="50%"}

```{r}
#| label: factors-numeric-danger-2b
#| echo: true
#| eval: true

# Correct way: convert via character
as.numeric(as.character(dose_factor))
# Returns: 10 20 50 100 200 (correct!)
```

:::
:::
:::

\

::: {.fragment}
**The danger:** Many functions silently convert factors to integers!
:::

## ⚠️ Missing Levels: The Silent Data Corruption

**Even worse: missing levels get renumbered!**

\

::: {.fragment}
```{r}
#| label: factors-missing-levels-1
#| echo: true
#| eval: true

# Groups 1, 2, 4, 5 (group 3 doesn't exist in your data)
groups <- c(1, 2, 4, 5, 1, 2, 4, 5)
response <- c(10, 15, 25, 30, 11, 16, 24, 29)

data.frame(group = groups, response = response)
```
:::

\

::: {.fragment}
```{r}
#| label: factors-missing-levels-2
#| echo: true
#| eval: true

# Convert to factor (happens during data import!)
groups_factor <- factor(groups)
str(groups_factor)
# Levels: "1" "2" "4" "5" - looks OK so far
```
:::

\

::: {.fragment}
::: {.columns}
::: {.column width="50%"}

```{r}
#| label: factors-missing-levels-3
#| echo: true
#| eval: true

# Try to convert back - DATA CORRUPTION!
as.numeric(groups_factor)
# Returns: 1 2 3 4 1 2 3 4
# Your group 4 became 3!
# Your group 5 became 4!
```

:::

::: {.column width="50%"}

```{r}
#| label: factors-missing-levels-4
#| echo: true
#| eval: true

# Correct conversion
as.numeric(as.character(groups_factor))
# Returns: 1 2 4 5 1 2 4 5 (correct!)
```

:::
:::
:::

\

::: {.fragment}
::: {.callout-warning}
## This is catastrophic for analysis!

Your statistical models will use the wrong group numbers. **Always use as.numeric(as.character(factor))** not as.numeric(factor)
:::
:::

## ⚠️ Numeric Factors After Reordering

**It gets worse when you've reordered the factor:**

\

::: {.fragment}
```{r}
#| label: factors-numeric-danger-reordered-setup
#| echo: true
#| eval: true

library(patchwork)

# Create data with doses as factors, reordered
dose_data <- data.frame(
  dose = factor(c(10, 20, 50, 100, 200)),
  response = c(5, 10, 25, 45, 80)
)

# Reorder by response (common operation!)
dose_data$dose_ordered <- fct_reorder(dose_data$dose, dose_data$response)
```
:::

\

::: {.fragment}
```{r}
#| label: factors-numeric-danger-reordered-convert
#| echo: true
#| eval: true

# Now try to use it numerically - DISASTER!
dose_data$wrong_numeric <- as.numeric(dose_data$dose_ordered)
dose_data$correct_numeric <- as.numeric(as.character(dose_data$dose_ordered))

print(data.frame(
  dose_ordered = dose_data$dose_ordered,
  wrong = dose_data$wrong_numeric,
  correct = dose_data$correct_numeric
))
```
:::

\

::: {.fragment}
```{r}
#| label: factors-numeric-danger-reordered-plot
#| echo: false
#| eval: true
#| fig-width: 11
#| fig-height: 4

# Show the disaster
p1 <- ggplot(dose_data, aes(x = wrong_numeric, y = response)) +
  geom_point(size = 3, color = "red") +
  geom_line() +
  labs(title = "WRONG: as.numeric(factor)",
       x = "as.numeric(dose_ordered)",
       y = "Response") +
  theme(plot.title = element_text(color = "red"))

p2 <- ggplot(dose_data, aes(x = correct_numeric, y = response)) +
  geom_point(size = 3, color = "darkgreen") +
  geom_line() +
  labs(title = "CORRECT: as.numeric(as.character(factor))",
       x = "Actual dose",
       y = "Response") +
  theme(plot.title = element_text(color = "darkgreen"))

p1 | p2
```
:::

## ⚠️ Function Ambiguity with Numeric Factors

**You're never sure how a function will treat numeric factors!**

\

::: {.fragment}
::: {.columns}
::: {.column width="45%"}

```{r}
#| label: factors-function-ambiguity
#| echo: true
#| eval: true

# Numeric data stored as factor (very common!)
values <- factor(c("5", "10", "20", "50", "100"))

# Different functions treat it differently:
mean(values)  # NA! Can't compute mean of factor
```

:::

::: {.column width="55%"}

```{r}
#| label: factors-function-ambiguity-1b
#| echo: true
#| eval: true

# Some functions use underlying integers:
as.numeric(values)  # 1 2 3 4 5 (WRONG!)

# Some functions coerce to character first:
paste("Dose:", values)  # Works as expected
```

:::
:::
:::

\

::: {.fragment}
**Real danger: statistical functions**

```{r}
#| label: factors-function-ambiguity-2
#| echo: true
#| eval: true

# Statistical models
dose_factor <- factor(c(10, 20, 50, 100))
response <- c(5, 10, 25, 45)

# This will use factor integers (1,2,3,4), not doses!
wrong_model <- lm(response ~ as.numeric(dose_factor))
coef(wrong_model)
```
:::

\

::: {.fragment}
```{r}
#| label: factors-function-ambiguity-3
#| echo: true
#| eval: true

# Correct approach
correct_model <- lm(response ~ as.numeric(as.character(dose_factor)))
coef(correct_model)

# The slope is completely different!
```

**Always check your data types before analysis!**
:::

## Recommendations: Avoid Numeric Factors

::: {.callout-warning}
## Best Practices

1. **Never store numeric values as factors** unless they represent categories
2. **Prefix categorical numbers**: Use "Group_1", "Group_2" instead of "1", "2"
3. **Check imported data**: CSV imports often convert numbers to factors
4. **Use `readr::read_csv()`** instead of `read.csv()` - better type detection
5. **Always convert via character**: `as.numeric(as.character(factor))` not `as.numeric(factor)`
6. **Check with `str()`** before analysis to verify data types
7. **For dose-response data**: Keep doses numeric, only convert to factor for plotting order
:::

\

::: {.fragment}
::: {.columns}
::: {.column width="50%"}

**Bad: Numeric categories**

```{r}
#| label: factors-numeric-bad-practice
#| echo: true
#| eval: true

# DON'T do this - ambiguous!
groups <- factor(c(1, 2, 4, 5))
str(groups)
# Are these numbers or categories?
```

:::

::: {.column width="50%"}

**Good: Prefixed categories**

```{r}
#| label: factors-numeric-good-practice
#| echo: true
#| eval: true

# DO this - clearly categorical!
groups <- factor(c("Group_1", "Group_2",
                   "Group_4", "Group_5"))
str(groups)
# Obviously categories, safe!
```

:::
:::
:::

\

::: {.fragment}
**For dose-response data:**

```{r}
#| label: factors-numeric-best-practice
#| echo: true
#| eval: false

# Keep doses numeric for analysis
dose_data <- data.frame(
  dose_numeric = c(10, 20, 50, 100, 200),
  response = c(5, 10, 25, 45, 80)
)

# Only convert to factor for plotting order:
ggplot(dose_data, aes(x = factor(dose_numeric), y = response)) +
  geom_boxplot()

# But use numeric for analysis:
model <- lm(response ~ dose_numeric, data = dose_data)
```
:::

## forcats Cheat Sheet

```{r}
#| label: factors-cheatsheet
#| echo: true
#| eval: false

library(forcats)

fct_reorder(f, x, fun)   # Order by another variable
fct_infreq(f)            # Order by frequency
fct_inorder(f)           # Order by appearance in data
fct_inseq(f)             # Order by numeric value (if purely numeric)
fct_rev(f)               # Reverse current order
fct_relevel(f, "A", "B") # Move specific levels to front
fct_recode(f, new = "old") # Rename levels
fct_lump_n(f, n = 5)     # Keep top n, lump others as "Other"
fct_explicit_na(f)       # Make NA a visible level

# For natural sort (var1, var2, var10):
factor(x, levels = gtools::mixedsort(unique(x)))
```


## Debugging Factor Issues

```{r}
#| label: factors-debugging
#| echo: true
#| eval: true

# Check current levels
levels(mtcars$cyl)

# Check level order
factor(mtcars$cyl) %>% levels()

# See factor structure
str(factor(mtcars$cyl))

# Convert to character if needed
mtcars$cyl_char <- as.character(mtcars$cyl)
```

## Key Takeaways & Best Practices

::: {.callout-important}
## Remember

**The Problem:**
- **R defaults to alphabetical** factor ordering - usually wrong!
- **Numeric factors are dangerous** - converting destroys your data
- **Missing levels get renumbered** - group 4 becomes 3!

**The Solutions:**
- **forcats package** provides powerful ordering tools:
  - **`fct_reorder()`** orders by another variable (most useful!)
  - **`fct_infreq()`** orders by frequency
  - **`fct_relevel()`** to put control/baseline first
  - **`fct_rev()`** to reverse order
- **Manual levels** for logical ordering (Low/Med/High, months, etc.)
- **Prefix categorical numbers**: "Group_1" not "1"

**Always:**
- **Check factor order** before plotting with `str()` or `levels()`
- **Convert via character**: `as.numeric(as.character(f))` not `as.numeric(f)`
- **Think about your reader** - what order makes sense?
:::
